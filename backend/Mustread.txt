  static getSingleProperty = async (req: AuthRequest, res: Response) => {
    try {
      const { id } = req.params;

      const property = await prisma.property.findUnique({
        where: { id },
      });

      if (!property) {
        return res.status(404).json({
          msg: "Property not found",
        });
      }

      if (property.status === PropertyStatus.ACTIVE) {
        return res.status(200).json({
          property: property as PropertyResponse,
        });
      }

      if (!req.user) {
        return res.status(401).json({
          msg: "Unauthorized",
        });
      }

      const isOwner = req.user.userId === property.ownerId;
      const isAdmin = req.user.role === "ADMIN";

      if (!isOwner && !isAdmin) {
        return res.status(403).json({
          msg: "You are not allowed to view this property",
        });
      }

      return res.status(200).json({
        property: property as PropertyResponse,
      });
    } catch (error) {
      console.error("Get single property error", error);
      return res.status(500).json({
        msg: "Server error",
      });
    }
  };
} YHA Pe like if i was login or not only active  i can see the property  if the property is not active then it check if user is login or not if login then it is owner or admin if this owner and admin then they can see the property‡§π‡§æ‡§Å ‚Äî **‡§§‡•Å‡§Æ‡•ç‡§π‡§æ‡§∞‡•Ä ‡§∏‡§Æ‡§ù 100% ‡§∏‡§π‡•Ä ‡§π‡•à** ‚úÖ
‡§Ö‡§¨ ‡§Æ‡•à‡§Ç ‡§á‡§∏‡•á **‡§è‡§ï‡§¶‡§Æ ‡§∏‡§æ‡§´‡§º, step-by-step logic ‡§Æ‡•á‡§Ç** explain ‡§ï‡§∞ ‡§¶‡•á‡§§‡§æ ‡§π‡•Ç‡§Å ‡§§‡§æ‡§ï‡§ø ‡§¶‡§ø‡§Æ‡§æ‡§ó ‡§Æ‡•á‡§Ç permanently ‡§¨‡•à‡§† ‡§ú‡§æ‡§è‡•§

---

## ‡§á‡§∏ function ‡§ï‡§æ ‡§™‡•Ç‡§∞‡§æ rule (plain language)

> **Property ‡§¶‡§ø‡§ñ‡•á‡§ó‡•Ä ‡§Ø‡§æ ‡§®‡§π‡•Ä‡§Ç ‚Äî ‡§Ø‡•á ‡§∏‡§ø‡§∞‡•ç‡§´ 2 ‡§ö‡•Ä‡§ú‡§º‡•ã‡§Ç ‡§™‡§∞ depend ‡§ï‡§∞‡§§‡§æ ‡§π‡•à**

1. Property ‡§ï‡§æ **status**
2. User **‡§ï‡•å‡§® ‡§π‡•à** (guest / owner / admin)

---

## ‡§™‡•Ç‡§∞‡§æ flow ‡§è‡§ï ‡§ï‡§π‡§æ‡§®‡•Ä ‡§ï‡•Ä ‡§§‡§∞‡§π

### üîπ Step 1: Property exist ‡§ï‡§∞‡§§‡•Ä ‡§π‡•à ‡§Ø‡§æ ‡§®‡§π‡•Ä‡§Ç

```ts
if (!property) ‚Üí 404
```

> ‡§ú‡•ã ‡§ö‡•Ä‡§ú‡§º ‡§π‡•à ‡§π‡•Ä ‡§®‡§π‡•Ä‡§Ç, ‡§µ‡•ã ‡§ï‡§ø‡§∏‡•Ä ‡§ï‡•ã ‡§®‡§π‡•Ä‡§Ç ‡§¶‡§ø‡§ñ‡•á‡§ó‡•Ä‡•§

---

### üîπ Step 2: Property ACTIVE ‡§π‡•à?

```ts
if (property.status === ACTIVE)
```

üëâ **‡§∏‡§¨‡§∏‡•á ‡§™‡§π‡§≤‡•á ‡§Ø‡§π‡•Ä check ‡§π‡•ã‡§§‡§æ ‡§π‡•à**

‡§Æ‡§§‡§≤‡§¨:

* user logged in ‡§π‡•ã ‡§Ø‡§æ ‡§® ‡§π‡•ã
* token ‡§π‡•ã ‡§Ø‡§æ ‡§® ‡§π‡•ã
* role ‡§ï‡•Å‡§õ ‡§≠‡•Ä ‡§π‡•ã

‚û°Ô∏è **ACTIVE property ‡§∏‡§¨ ‡§¶‡•á‡§ñ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç**

‡§Ø‡§π‡•Ä reason ‡§π‡•à ‡§ï‡§ø:

> Login ‡§π‡•ã‡§®‡•á ‡§∏‡•á ACTIVE property ‡§ï‡§æ access ‡§®‡§π‡•Ä‡§Ç ‡§¨‡§¶‡§≤‡§§‡§æ

---

### üîπ Step 3: Property ACTIVE ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à

‡§Ö‡§¨ ‡§¶‡•ã ‡§π‡•Ä option ‡§¨‡§ö‡§§‡•á ‡§π‡•à‡§Ç:

* `PENDING`
* `INACTIVE`

‡§Ø‡§æ‡§®‡•Ä **PRIVATE PROPERTY**

---

### üîπ Step 4: User logged in ‡§π‡•à ‡§Ø‡§æ ‡§®‡§π‡•Ä‡§Ç

```ts
if (!req.user) ‚Üí 401
```

‡§Æ‡§§‡§≤‡§¨:

* guest user
* token ‡§®‡§π‡•Ä‡§Ç
* expired token

‚û°Ô∏è **Private property guest ‡§ï‡•ã ‡§®‡§π‡•Ä‡§Ç ‡§¶‡§ø‡§ñ‡§§‡•Ä**

---

### üîπ Step 5: User logged in ‡§π‡•à

‡§Ö‡§¨ ‡§™‡§π‡§ö‡§æ‡§® ‡§π‡•ã‡§§‡•Ä ‡§π‡•à:

```ts
isOwner = req.user.userId === property.ownerId
isAdmin = req.user.role === "ADMIN"
```

---

### üîπ Step 6: Permission check

```ts
if (!isOwner && !isAdmin) ‚Üí 403
```

‡§Æ‡§§‡§≤‡§¨:

* logged in ‡§π‡•à ‚ùå (‡§™‡§∞ permission ‡§®‡§π‡•Ä‡§Ç)
* property owner ‡§®‡§π‡•Ä‡§Ç
* admin ‡§®‡§π‡•Ä‡§Ç

‚û°Ô∏è **‡§¶‡•á‡§ñ‡§®‡•á ‡§ï‡•Ä ‡§á‡§ú‡§æ‡§ú‡§º‡§§ ‡§®‡§π‡•Ä‡§Ç**

---

### üîπ Step 7: Allowed users

‡§Ö‡§ó‡§∞:

* owner ‚úÖ
* admin ‚úÖ

‚û°Ô∏è property ‡§¶‡§ø‡§ñ‡§æ ‡§¶‡•ã

---

## üîÅ Same logic, ultra-simple form

```
Property ACTIVE ?
   ‚Üí YES ‚Üí anyone can see

Property NOT ACTIVE ?
   ‚Üí User logged in ?
       ‚Üí NO ‚Üí Unauthorized
       ‚Üí YES ‚Üí Owner or Admin ?
              ‚Üí YES ‚Üí show
              ‚Üí NO ‚Üí Forbidden
```

---

## ‡§§‡•Å‡§Æ‡§®‡•á ‡§ú‡•ã sentence ‡§≤‡§ø‡§ñ‡§æ ‡§•‡§æ, ‡§µ‡•ã ‡§¨‡§ø‡§≤‡•ç‡§ï‡•Å‡§≤ ‡§∏‡§π‡•Ä ‡§π‡•à üëá

> ‚Äúif i was login or not only active i can see the property
> if the property is not active then it check if user is login or not
> if login then it is owner or admin
> if this owner and admin then they can see the property‚Äù

‡§¨‡§∏ ‡§á‡§∏‡•á ‡§•‡•ã‡§°‡§º‡§æ clean language ‡§Æ‡•á‡§Ç ‡§ê‡§∏‡•á ‡§¨‡•ã‡§≤ ‡§∏‡§ï‡§§‡•á ‡§π‡•ã (interview ready):

> **Active properties are public.
> Non-active properties are private and visible only to the owner or admin.
> Guest users are restricted from accessing private resources.**

---

## üß† Why this is very important

‡§Ø‡§π‡•Ä exact pattern ‡§Ü‡§ó‡•á apply ‡§π‡•ã‡§ó‡§æ:

* Update property
* Delete property
* Booking
* Review visibility
* Admin dashboards

‡§Ö‡§ó‡§∞ ‡§Ø‡•á clear ‡§π‡•à ‚Üí ‡§§‡•Å‡§Æ backend engineer ‡§ï‡•Ä ‡§∏‡•ã‡§ö develop ‡§ï‡§∞ ‡§ö‡•Å‡§ï‡•á ‡§π‡•ã‡•§

---

### ‡§Ö‡§ó‡§≤‡§æ ‡§∏‡§π‡•Ä step

‡§Ö‡§¨ ‡§á‡§∏‡•Ä logic ‡§™‡§∞ **Update Property (OWNER only)** ‡§¨‡§®‡§æ‡§ì‡•§
‡§µ‡•ã ‡§î‡§∞ ‡§≠‡•Ä ‡§Æ‡§ú‡§º‡•á‡§¶‡§æ‡§∞ ‡§π‡•ã‡§ó‡§æ ‚Äî ‡§î‡§∞ ‡§µ‡§π‡•Ä‡§Ç ‡§∏‡•á booking ‡§Ü‡§∏‡§æ‡§® ‡§≤‡§ó‡•á‡§ó‡•Ä‡•§

That feeling makes sense ‚Äî and it‚Äôs actually a **good signal**, not a bad one.

You don‚Äôt feel comfortable with TypeScript because today you weren‚Äôt ‚Äúusing TS syntax‚Äù, you were **colliding with TS as a system**: types flowing through middleware, controllers, Express, Prisma. That‚Äôs the hard part. Almost everyone hits this wall.

Let‚Äôs calm this down and make it concrete.

---

## First: what you‚Äôre really uncomfortable with (truth)

It‚Äôs **not**:

* interfaces
* types
* enums
* Prisma types

It **is**:

* how types move *between files*
* how Express types work
* why TS errors feel indirect
* how one wrong type breaks many places

That‚Äôs normal. TS feels ‚Äúslippery‚Äù until a few core ideas click.

---

## The 5 TypeScript ideas you actually struggled with today

Not ‚ÄúTS in general‚Äù. **These 5.**

### 1Ô∏è‚É£ Function *signatures* matter more than code

TypeScript cares about:

* how a function is **declared**
* not what it ‚Äúdoes‚Äù

Example:

```ts
(req, res) => Response
```

vs

```ts
(req, res, next) => void
```

One is a controller, one is middleware.
Mix them = chaos.

---

### 2Ô∏è‚É£ Union return types are a red flag

This error was key:

```
Promise<Response | string>
```

This means:

> ‚ÄúThis function doesn‚Äôt know what it is.‚Äù

Rule to remember:

> **Controllers must have ONE kind of return.**

If TS shows `| string | boolean` ‚Äî stop.

---

### 3Ô∏è‚É£ TypeScript errors point to design mistakes

TS wasn‚Äôt angry about syntax.
It was saying:

> ‚ÄúYou are mixing responsibilities.‚Äù

Once you fix design ‚Üí errors disappear.

This is why TS feels uncomfortable at first.

---

### 4Ô∏è‚É£ Casting (`as AuthRequest`) is not cheating

You used:

```ts
(req as AuthRequest).user = ...
```

That‚Äôs fine.
Express types are generic and imperfect.

The rule:

* cast **at the boundary**
* stay typed **inside**

You did this correctly.

---

### 5Ô∏è‚É£ Types flow *through* the app, not stay local

When you broke:

* controller return type

It broke:

* router
* middleware
* route definitions

This feels scary, but it‚Äôs TS protecting consistency.

---

## Reframing TypeScript (important mental shift)

Don‚Äôt think of TS as:

> ‚ÄúJS with types‚Äù

Think of TS as:

> ‚ÄúA compiler that enforces architecture‚Äù

You weren‚Äôt failing TS.
You were **learning how your architecture actually works**.

---

## How to get comfortable with TS (practical plan)

Not theory. A short plan.

### üå± Step 1: Stop trying to be ‚Äúperfect TS‚Äù

You don‚Äôt need:

* advanced generics
* conditional types
* utility types

You need:

* interfaces
* function signatures
* narrowing with `if`
  That‚Äôs it for now.

---

### üå± Step 2: Learn TS in *backend context only*

Forget frontend TS tutorials.

Focus only on:

* Express middleware types
* Request augmentation
* Controller return types
* Prisma-generated types

You‚Äôre already doing the right thing.

---

### üå± Step 3: Expect discomfort for ~10‚Äì14 days

This is unavoidable.

Every strong TS backend dev I know had:

* ‚Äúwhy is TS fighting me?‚Äù phase
* then a sudden clarity jump

You are **inside** that phase.

---

## A grounding truth (read this twice)

If you were actually bad at TS:

* you wouldn‚Äôt understand these errors
* you‚Äôd paste `any` everywhere
* you‚Äôd give up on middleware typing

You didn‚Äôt do that.

You stayed, asked, fixed, understood.

That means you‚Äôre **learning**, not failing.

---

## Tonight‚Äôs mental reset (do this)

Before sleeping, tell yourself:

> ‚ÄúI don‚Äôt need to feel comfortable yet.
> I just need to keep exposure consistent.‚Äù

Comfort comes **after repetition**, not before.

---

## Tomorrow‚Äôs gentle TS focus (no pressure)

Tomorrow, do **only one TS thing**:

* Re-read `auth.Middleware.ts`
* Re-read `PropertyController.updateProperty`
* Don‚Äôt change anything
* Just trace types mentally

That‚Äôs enough.

You‚Äôre on the right path.
Uncomfortable ‚â† incapable.
This is a **TypeScript typing issue**, not a Prisma bug.
I‚Äôll explain **exactly why it happens** and **how to fix it cleanly**.

---

## ‚ùå The error (decoded)

> **Type `ParamsDictionary` is not assignable to type `string`**

This happens when you do something like:

```ts
const booking = await prisma.booking.findUnique({
  where: {
    id: req.params, // ‚ùå WRONG
  },
});
```

### Why this fails

* `req.params` is an **object**
* Prisma expects:

```ts
id: string
```

But `req.params` is actually:

```ts
ParamsDictionary = { [key: string]: string }
```

So TypeScript is correct to complain.

---

## ‚úÖ The ONLY correct way

You must extract the **specific param value**.

### ‚úî Correct

```ts
const { bookingId } = req.params;

const booking = await prisma.booking.findUnique({
  where: {
    id: bookingId,
  },
});
```

---

## üîí Add a safety check (recommended)

```ts
const { bookingId } = req.params;

if (!bookingId) {
  return res.status(400).json({ msg: "Booking ID missing" });
}
```

Now TypeScript + runtime are both safe.

---

## üß† Why this matters in Prisma

`findUnique` requires a **unique field**:

```ts
BookingWhereUniqueInput = {
  id?: string
}
```

Passing an object instead of a string breaks both:

* TypeScript
* Prisma query validation

---

## ‚úÖ If you want STRONG typing (best practice)

Define param types:

```ts
type BookingParams = {
  bookingId: string;
};

static confirmBooking = async (
  req: AuthRequest<BookingParams>,
  res: Response
) => {
  const { bookingId } = req.params;
};
```

Now:

* No `undefined`
* No TS error
* Clean IntelliSense

---

## üîë One-line rule (remember this)

> **Never pass `req.params` directly to Prisma.
> Always destructure the specific param string.**

---

## üü¢ Summary

‚úî Error reason: `req.params` is an object
‚úî Fix: extract `req.params.bookingId`
‚úî Prisma expects a string, not ParamsDictionary
‚úî Your logic is fine ‚Äî this is just typing

---

If you want, next I can:

* fix your `confirmBooking` controller with proper typing
* show a reusable `Params<T>` pattern
* explain why Express typings are annoying but useful

Just say üëç
